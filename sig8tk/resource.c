#include "sig8tk.h"

Resource *resources = NULL;
int resourceCount = 0;

void InvalidFileFormat()
{
    fprintf(stderr, "Error reading file.\n");
    Finalize();
    exit(EXIT_FAILURE);
}

static int SortResourcesCmp(const void *lhs, const void *rhs)
{
    return strcmp(((Resource*)lhs)->name, ((Resource*)rhs)->name);
}

void SortResources(void)
{
    qsort(resources, resourceCount, sizeof(Resource), SortResourcesCmp);
}

void FreeResource(Resource *resource)
{
    if (resource->type == RESOURCE_SPRITE) {
        free(resource->sprite.data);
    }
}

void FreeResources(void)
{
    if (!resources) {
        return;
    }

    for (int i = 0; i < resourceCount; ++i) {
        free(&resources[i]);
    }

    free(resources);
}

void WriteResource(const Resource *resource, FILE *file)
{
    fprintf(file, "//!sig8 %d %s\n", resource->type, resource->name);

    if (resource->type == RESOURCE_SPRITE) {
        ResourceSprite sprite = resource->sprite;

        fprintf(file, "extern const Sprite %s;\n", resource->name);
        fprintf(file, "#ifdef SIG8_COMPILE_RESOURCES\n");
        fprintf(file, "static const uint8_t %s_Data[];\n", resource->name);
        fprintf(file, "static const SpriteDefinition %s_Def = {\n", resource->name);
        fprintf(file, "%d, %d, %s_Def\n", sprite.width, sprite.height, resource->name);
        fprintf(file, "};\n");
        fprintf(file, "const Sprite %s = &%s_Def;\n", resource->name, resource->name);

        fprintf(file, "static const uint8_t %s_Data[] = {\n", resource->name);
        for (int j = 0; j < sprite.height; ++j) {
            for (int i = 0; i < sprite.width; ++i) {
                fprintf(file, "%d, ", sprite.data[i + j * sprite.width]);
            }
            fprintf(file, "\n");
        }
        fprintf(file, "};\n");
        fprintf(file, "#endif\n");
    }
}

void WriteResources(FILE *file)
{
    fprintf(file, "// This file was autogenerated by sig8tk\n");
    fprintf(file, "// Please do not edit it\n");
    fprintf(file, "#pragma once\n");
    for (int i = 0; i < resourceCount; ++i) {
        WriteResource(&resources[i], file);
    }
}

void ReadResourceSprite(ResourceSprite *sprite, FILE *file)
{
    char buf[MAX_LINE_LENGTH];
    fgets(buf, sizeof buf, file); // extern const Sprite NAME;
    fgets(buf, sizeof buf, file); // #ifdef SIG8_COMPILE_RESOURCES
    fgets(buf, sizeof buf, file); // static const uint8_t NAME_Data[];
    fgets(buf, sizeof buf, file); // static const SpriteDefinition NAME_Def = {
    fgets(buf, sizeof buf, file); // width, height, NAME_Def
    sscanf(buf, "%d, %d", &sprite->width, &sprite->height);
    sprite->frames = 1;
    if (sprite->width > MAX_SPRITE_DIMENSION || sprite->height > MAX_SPRITE_DIMENSION) {
        InvalidFileFormat();
    }
    sprite->data = malloc(sprite->width * sprite->height);
    fgets(buf, sizeof buf, file); // };
    fgets(buf, sizeof buf, file); // const Sprite NAME = &NAME_Def;
    fgets(buf, sizeof buf, file); // static const uint8_t NAME_Data[] = {
    int idx = 0;
    for (int j = 0; j < sprite->height; ++j) {
        fgets(buf, sizeof buf, file);
        char *s = strtok(buf, ", ");
        for (int i = 0; i < sprite->width; ++i) {
            sprite->data[idx++] = atoi(s);
            s = strtok(NULL, ", ");
        }
    }
    fgets(buf, sizeof buf, file); // };
    fgets(buf, sizeof buf, file); // #endif
}

void ReadResources(FILE *file)
{
    FreeResources();
    char buf[MAX_LINE_LENGTH];
    resourceCount = 0;

    while (!feof(file)) {
        fgets(buf, sizeof buf, file);
        if (strncmp("//!sig8", buf, 7) == 0) {
            ++resourceCount;
        }
    }

    resources = malloc(sizeof(Resource) * resourceCount);
    Resource *cur = resources;
    rewind(file);

    while (!feof(file)) {
        buf[0] = 0;
        fgets(buf, sizeof buf, file);
        if (strncmp("//!sig8", buf, 7) != 0) {
            continue;
        }

        sscanf(buf + 8, "%d %31s", &cur->type, cur->name);
        if (cur->type == RESOURCE_SPRITE) {
            ReadResourceSprite(&cur->sprite, file);
        }

        ++cur;
    }
    SortResources();
}

void RemoveResource(Resource *resource)
{
    FreeResource(resource);
    *resource = resources[resourceCount - 1];
    resources = realloc(resources, sizeof(Resource) * (resourceCount - 1));
    --resourceCount;
    SortResources();
}

void CreateResource(const char *name, ResourceType type)
{
    resources = realloc(resources, sizeof(Resource) * (resourceCount + 1));
    strcpy(resources[resourceCount].name, name);
    resources[resourceCount].type = type;

    switch (type) {
    case RESOURCE_SPRITE:
        InitSprite(&resources[resourceCount].sprite, 8, 8);
        break;
    }

    ++resourceCount;
    SortResources();
}
